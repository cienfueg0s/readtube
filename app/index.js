// server/index.ts
import express3 from "express";

// server/routes.ts
import { createServer } from "http";
import express from "express";
import path from "path";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
var rootPath = path.join(__dirname, "..");
async function registerRoutes(app2) {
  app2.get("/api/transcript", async (req, res) => {
    try {
      const { videoId } = req.query;
      if (!videoId || typeof videoId !== "string") {
        return res.status(400).json({ message: "Video ID is required" });
      }
      const mockTranscript = `This is a sample transcript for video ID: ${videoId}. 
In a real extension, this would contain the actual transcript text from the YouTube video.
The transcript would continue with more content here and include timestamps as needed.
Users can then interact with this text, search it, or use it for AI analysis.`;
      const timestamps = [
        { text: "This is a sample transcript for video ID", time: 0 },
        { text: "In a real extension, this would contain the actual transcript text", time: 5 },
        { text: "The transcript would continue with more content here", time: 10 },
        { text: "Users can then interact with this text, search it", time: 15 }
      ];
      return res.json({
        transcript: mockTranscript,
        timestamps,
        title: `Sample Video ${videoId}`,
        channel: "Demo Channel",
        duration: "10:45",
        availableLanguages: [
          { code: "en", name: "English" },
          { code: "es", name: "Spanish" },
          { code: "fr", name: "French" }
        ]
      });
    } catch (error) {
      console.error("Error fetching transcript:", error);
      return res.status(500).json({ message: "Failed to fetch transcript" });
    }
  });
  app2.post("/api/chat", express.json(), async (req, res) => {
    try {
      const { message, videoId, transcript } = req.body;
      if (!message) {
        return res.status(400).json({ message: "Message is required" });
      }
      const mockResponse = `This is a simulated AI response to your message: "${message}"
      
Regarding the video you're watching: The transcript you provided gives context about ${transcript ? transcript.substring(0, 50) + "..." : "the video content"}.

For a real implementation, this would be generated by a language model that has access to the full transcript and can provide more meaningful responses.`;
      return res.json({ response: mockResponse });
    } catch (error) {
      console.error("Error in chat endpoint:", error);
      return res.status(500).json({ message: "Failed to process chat message" });
    }
  });
  app2.post("/api/analyze-code", express.json(), async (req, res) => {
    try {
      const { code, analysisType } = req.body;
      if (!code || !analysisType) {
        return res.status(400).json({ message: "Code and analysis type are required" });
      }
      let response = "Analysis results would appear here in a real implementation.";
      switch (analysisType) {
        case "explain":
          response = `# Code Explanation

This would be a detailed explanation of how your code works.`;
          break;
        case "optimize":
          response = `# Optimization Suggestions

In a real implementation, this would contain specific suggestions for improving your code.`;
          break;
        case "findbugs":
          response = `# Potential Issues

A real implementation would identify potential bugs or issues in your code.`;
          break;
        case "document":
          response = `/**
 * Documentation Generated
 * 
 * @description This would be auto-generated documentation for your code
 */`;
          break;
        default:
          response = "Invalid analysis type specified.";
      }
      return res.json({ analysis: response });
    } catch (error) {
      console.error("Error in code analysis endpoint:", error);
      return res.status(500).json({ message: "Failed to analyze code" });
    }
  });
  app2.get("/test-extension", (req, res) => {
    res.sendFile(path.join(rootPath, "test-extension.html"));
  });
  app2.use("/unified-extension", express.static(path.join(rootPath, "unified-extension")));
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express2 from "express";
import fs from "fs";
import path3, { dirname as dirname2 } from "path";
import { fileURLToPath as fileURLToPath3 } from "url";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path2, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath as fileURLToPath2 } from "url";
var __filename2 = fileURLToPath2(import.meta.url);
var __dirname2 = dirname(__filename2);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path2.resolve(__dirname2, "client", "src"),
      "@shared": path2.resolve(__dirname2, "shared"),
      "@assets": path2.resolve(__dirname2, "attached_assets")
    }
  },
  root: path2.resolve(__dirname2, "client"),
  build: {
    outDir: path2.resolve(__dirname2, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var __filename3 = fileURLToPath3(import.meta.url);
var __dirname3 = dirname2(__filename3);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path3.resolve(
        __dirname3,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path3.resolve(__dirname3, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express2.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path3.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express3();
app.use(express3.json());
app.use(express3.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path4 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path4.startsWith("/api")) {
      let logLine = `${req.method} ${path4} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = 5e3;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();
